// Code generated by protoc-gen-go. DO NOT EDIT.
// source: common/configuration.proto

package common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// HashingAlgorithm is encoded into the configuration transaction as  a configuration item of type Chain
// with a Key of "HashingAlgorithm" and a Value of  HashingAlgorithm as marshaled protobuf bytes
type HashingAlgorithm struct {
	// Currently supported algorithms are: SHAKE256
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *HashingAlgorithm) Reset()                    { *m = HashingAlgorithm{} }
func (m *HashingAlgorithm) String() string            { return proto.CompactTextString(m) }
func (*HashingAlgorithm) ProtoMessage()               {}
func (*HashingAlgorithm) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *HashingAlgorithm) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
// type Chain with a Key of "BlockDataHashingStructure" and a Value of HashingAlgorithm as marshaled protobuf bytes
type BlockDataHashingStructure struct {
	// width specifies the width of the Merkle tree to use when computing the BlockDataHash
	// in order to replicate flat hashing, set this width to MAX_UINT32
	Width uint32 `protobuf:"varint,1,opt,name=width" json:"width,omitempty"`
}

func (m *BlockDataHashingStructure) Reset()                    { *m = BlockDataHashingStructure{} }
func (m *BlockDataHashingStructure) String() string            { return proto.CompactTextString(m) }
func (*BlockDataHashingStructure) ProtoMessage()               {}
func (*BlockDataHashingStructure) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *BlockDataHashingStructure) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

// OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
// with a Key of "OrdererAddresses" and a Value of OrdererAddresses as marshaled protobuf bytes
type OrdererAddresses struct {
	Addresses []string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
}

func (m *OrdererAddresses) Reset()                    { *m = OrdererAddresses{} }
func (m *OrdererAddresses) String() string            { return proto.CompactTextString(m) }
func (*OrdererAddresses) ProtoMessage()               {}
func (*OrdererAddresses) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *OrdererAddresses) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// Consortium represents the consortium context in which the channel was created
type Consortium struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Consortium) Reset()                    { *m = Consortium{} }
func (m *Consortium) String() string            { return proto.CompactTextString(m) }
func (*Consortium) ProtoMessage()               {}
func (*Consortium) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Consortium) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Capabilities message contains all the capabilities that a channel requires
// participant entities to comply with. The entity should drop off the channel
// if it can't fulfill any of the required capabilities.
// Capabilities is encoded into the configuaration as Values of each type
// Orderer, Channel, or Application.
// The key string should represent the capability name, and it must be unique
// within each type. For readability, it may be advisable to prefix the key with
// its type (eg app-acl)
type Capabilities struct {
	Capabilities map[string]*Capability `protobuf:"bytes,1,rep,name=capabilities" json:"capabilities,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Capabilities) Reset()                    { *m = Capabilities{} }
func (m *Capabilities) String() string            { return proto.CompactTextString(m) }
func (*Capabilities) ProtoMessage()               {}
func (*Capabilities) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *Capabilities) GetCapabilities() map[string]*Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Capability holds a set of options. We can add more as needed in the
// future. For now, whether it is required or not. If a configured capability
// is not required, it must be completely compatible with previous releases.
// Compatible features are not required to be encoded as capabilities; they
// only provide flexibility for the admins to control the features.
type Capability struct {
	Required bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
}

func (m *Capability) Reset()                    { *m = Capability{} }
func (m *Capability) String() string            { return proto.CompactTextString(m) }
func (*Capability) ProtoMessage()               {}
func (*Capability) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *Capability) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func init() {
	proto.RegisterType((*HashingAlgorithm)(nil), "common.HashingAlgorithm")
	proto.RegisterType((*BlockDataHashingStructure)(nil), "common.BlockDataHashingStructure")
	proto.RegisterType((*OrdererAddresses)(nil), "common.OrdererAddresses")
	proto.RegisterType((*Consortium)(nil), "common.Consortium")
	proto.RegisterType((*Capabilities)(nil), "common.Capabilities")
	proto.RegisterType((*Capability)(nil), "common.Capability")
}

func init() { proto.RegisterFile("common/configuration.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 329 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0x41, 0x6b, 0xea, 0x40,
	0x10, 0xc7, 0x89, 0x3e, 0x45, 0x47, 0x1f, 0xf8, 0x96, 0x77, 0xf0, 0xc9, 0x3b, 0x84, 0x50, 0x24,
	0x50, 0x48, 0x5a, 0x7b, 0x29, 0xbd, 0xa9, 0x2d, 0x94, 0x5e, 0x0a, 0xf1, 0xd6, 0xdb, 0x26, 0x19,
	0x93, 0xc5, 0x24, 0x6b, 0x67, 0x77, 0x5b, 0xf2, 0xa9, 0xfa, 0x15, 0x8b, 0x59, 0x5b, 0x15, 0x7b,
	0x9b, 0x5f, 0xe6, 0xf7, 0x9f, 0x99, 0xb0, 0x30, 0x49, 0x64, 0x59, 0xca, 0x2a, 0x4c, 0x64, 0xb5,
	0x16, 0x99, 0x21, 0xae, 0x85, 0xac, 0x82, 0x2d, 0x49, 0x2d, 0x59, 0xd7, 0xf6, 0xbc, 0x29, 0x8c,
	0x1e, 0xb9, 0xca, 0x45, 0x95, 0xcd, 0x8b, 0x4c, 0x92, 0xd0, 0x79, 0xc9, 0x18, 0xfc, 0xaa, 0x78,
	0x89, 0x63, 0xc7, 0x75, 0xfc, 0x7e, 0xd4, 0xd4, 0xde, 0x35, 0xfc, 0x5b, 0x14, 0x32, 0xd9, 0xdc,
	0x73, 0xcd, 0xf7, 0x81, 0x95, 0x26, 0x93, 0x68, 0x43, 0xc8, 0xfe, 0x42, 0xe7, 0x5d, 0xa4, 0x3a,
	0x6f, 0x12, 0xbf, 0x23, 0x0b, 0xde, 0x15, 0x8c, 0x9e, 0x29, 0x45, 0x42, 0x9a, 0xa7, 0x29, 0xa1,
	0x52, 0xa8, 0xd8, 0x7f, 0xe8, 0xf3, 0x2f, 0x18, 0x3b, 0x6e, 0xdb, 0xef, 0x47, 0x87, 0x0f, 0x9e,
	0x0b, 0xb0, 0x94, 0x95, 0x92, 0xa4, 0x85, 0xf9, 0xf9, 0x8c, 0x0f, 0x07, 0x86, 0x4b, 0xbe, 0xe5,
	0xb1, 0x28, 0x84, 0x16, 0xa8, 0xd8, 0x13, 0x0c, 0x93, 0x23, 0x6e, 0x66, 0x0e, 0x66, 0xd3, 0xc0,
	0xfe, 0x5e, 0x70, 0xec, 0x9e, 0xc0, 0x43, 0xa5, 0xa9, 0x8e, 0x4e, 0xb2, 0x93, 0x15, 0xfc, 0x39,
	0x53, 0xd8, 0x08, 0xda, 0x1b, 0xac, 0xf7, 0x47, 0xec, 0x4a, 0xe6, 0x43, 0xe7, 0x8d, 0x17, 0x06,
	0xc7, 0x2d, 0xd7, 0xf1, 0x07, 0x33, 0x76, 0xb6, 0xab, 0x8e, 0xac, 0x70, 0xd7, 0xba, 0x75, 0x3c,
	0x1f, 0xe0, 0xd0, 0x60, 0x13, 0xe8, 0x11, 0xbe, 0x1a, 0x41, 0x98, 0x36, 0x23, 0x7b, 0xd1, 0x37,
	0x2f, 0x56, 0x70, 0x21, 0x29, 0x0b, 0xf2, 0x7a, 0x8b, 0x54, 0x60, 0x9a, 0x21, 0x05, 0x6b, 0x1e,
	0x93, 0x48, 0xec, 0x93, 0xa9, 0xfd, 0x9e, 0x97, 0xcb, 0x4c, 0xe8, 0xdc, 0xc4, 0x3b, 0x0c, 0x8f,
	0xe4, 0xd0, 0xca, 0xa1, 0x95, 0x43, 0x2b, 0xc7, 0xdd, 0x06, 0x6f, 0x3e, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x62, 0x6f, 0x69, 0xeb, 0x0c, 0x02, 0x00, 0x00,
}
