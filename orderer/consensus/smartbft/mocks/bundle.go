// Code generated by mockery v2.14.1. DO NOT EDIT.

package mocks

import (
	channelconfig "github.com/hyperledger/fabric/common/channelconfig"
	configtx "github.com/hyperledger/fabric/common/configtx"

	mock "github.com/stretchr/testify/mock"

	msp "github.com/hyperledger/fabric/msp"

	policies "github.com/hyperledger/fabric/common/policies"
)

// Bundle is an autogenerated mock type for the Bundle type
type Bundle struct {
	mock.Mock
}

// ApplicationConfig provides a mock function with given fields:
func (_m *Bundle) ApplicationConfig() (channelconfig.Application, bool) {
	ret := _m.Called()

	var r0 channelconfig.Application
	if rf, ok := ret.Get(0).(func() channelconfig.Application); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(channelconfig.Application)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ChannelConfig provides a mock function with given fields:
func (_m *Bundle) ChannelConfig() channelconfig.Channel {
	ret := _m.Called()

	var r0 channelconfig.Channel
	if rf, ok := ret.Get(0).(func() channelconfig.Channel); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(channelconfig.Channel)
		}
	}

	return r0
}

// ConfigtxValidator provides a mock function with given fields:
func (_m *Bundle) ConfigtxValidator() configtx.Validator {
	ret := _m.Called()

	var r0 configtx.Validator
	if rf, ok := ret.Get(0).(func() configtx.Validator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(configtx.Validator)
		}
	}

	return r0
}

// ConsortiumsConfig provides a mock function with given fields:
func (_m *Bundle) ConsortiumsConfig() (channelconfig.Consortiums, bool) {
	ret := _m.Called()

	var r0 channelconfig.Consortiums
	if rf, ok := ret.Get(0).(func() channelconfig.Consortiums); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(channelconfig.Consortiums)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MSPManager provides a mock function with given fields:
func (_m *Bundle) MSPManager() msp.MSPManager {
	ret := _m.Called()

	var r0 msp.MSPManager
	if rf, ok := ret.Get(0).(func() msp.MSPManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(msp.MSPManager)
		}
	}

	return r0
}

// OrdererConfig provides a mock function with given fields:
func (_m *Bundle) OrdererConfig() (channelconfig.Orderer, bool) {
	ret := _m.Called()

	var r0 channelconfig.Orderer
	if rf, ok := ret.Get(0).(func() channelconfig.Orderer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(channelconfig.Orderer)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// PolicyManager provides a mock function with given fields:
func (_m *Bundle) PolicyManager() policies.Manager {
	ret := _m.Called()

	var r0 policies.Manager
	if rf, ok := ret.Get(0).(func() policies.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(policies.Manager)
		}
	}

	return r0
}

// ValidateNew provides a mock function with given fields: resources
func (_m *Bundle) ValidateNew(resources channelconfig.Resources) error {
	ret := _m.Called(resources)

	var r0 error
	if rf, ok := ret.Get(0).(func(channelconfig.Resources) error); ok {
		r0 = rf(resources)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewBundle interface {
	mock.TestingT
	Cleanup(func())
}

// NewBundle creates a new instance of Bundle. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewBundle(t mockConstructorTestingTNewBundle) *Bundle {
	mock := &Bundle{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
