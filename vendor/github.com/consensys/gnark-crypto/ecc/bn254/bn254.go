// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package bn254 efficient elliptic curve, pairing and hash to curve implementation for bn254. This curve appears in
// Ethereum pre-compiles as altbn128.
//
// bn254: A Barreto--Naerig curve with
//
//	seed xâ‚€=4965661367192848881
//	ğ”½r: r=21888242871839275222246405745257275088548364400416034343698204186575808495617 (36xâ‚€â´+36xâ‚€Â³+18xâ‚€Â²+6xâ‚€+1)
//	ğ”½p: p=21888242871839275222246405745257275088696311157297823662689037894645226208583 (36xâ‚€â´+36xâ‚€Â³+24xâ‚€Â²+6xâ‚€+1)
//	(E/ğ”½p): YÂ²=XÂ³+3
//	(Eâ‚œ/ğ”½pÂ²): YÂ² = XÂ³+3/(u+9) (D-type twist)
//	r âˆ£ #E(Fp) and r âˆ£ #Eâ‚œ(ğ”½pÂ²)
//
// Extension fields tower:
//
//	ğ”½pÂ²[u] = ğ”½p/uÂ²+1
//	ğ”½pâ¶[v] = ğ”½pÂ²/vÂ³-9-u
//	ğ”½pÂ¹Â²[w] = ğ”½pâ¶/wÂ²-v
//
// optimal Ate loop size:
//
//	6xâ‚€+2
//
// Security: estimated 103-bit level following [https://eprint.iacr.org/2019/885.pdf]
// (r is 254 bits and pÂ¹Â² is 3044 bits)
//
// # Warning
//
// This code has been partially audited and is provided as-is. In particular, there is no security guarantees such as constant time implementation or side-channel attack resistance.
package bn254

import (
	"math/big"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/ecc/bn254/fp"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/internal/fptower"
)

// ID bn254 ID
const ID = ecc.BN254

// aCurveCoeff is the a coefficients of the curve YÂ²=XÂ³+ax+b
var aCurveCoeff fp.Element
var bCurveCoeff fp.Element

// twist
var twist fptower.E2

// bTwistCurveCoeff b coeff of the twist (defined over ğ”½pÂ²) curve
var bTwistCurveCoeff fptower.E2

// generators of the r-torsion group, resp. in ker(pi-id), ker(Tr)
var g1Gen G1Jac
var g2Gen G2Jac

var g1GenAff G1Affine
var g2GenAff G2Affine

// point at infinity
var g1Infinity G1Jac
var g2Infinity G2Jac

// optimal Ate loop counter
var loopCounter [66]int8

// Parameters useful for the GLV scalar multiplication. The third roots define the
// endomorphisms Ï•â‚ and Ï•â‚‚ for <G1Affine> and <G2Affine>. lambda is such that <r, Ï•-Î»> lies above
// <r> in the ring Z[Ï•]. More concretely it's the associated eigenvalue
// of Ï•â‚ (resp Ï•â‚‚) restricted to <G1Affine> (resp <G2Affine>)
// see https://www.cosic.esat.kuleuven.be/nessie/reports/phase2/GLV.pdf
var thirdRootOneG1 fp.Element
var thirdRootOneG2 fp.Element
var lambdaGLV big.Int

// glvBasis stores R-linearly independent vectors (a,b), (c,d)
// in ker((u,v) â†’ u+vÎ»[r]), and their determinant
var glvBasis ecc.Lattice

// Ïˆ o Ï€ o Ïˆâ»Â¹, where Ïˆ:E â†’ E' is the degree 6 iso defined over ğ”½pÂ¹Â²
var endo struct {
	u fptower.E2
	v fptower.E2
}

// seed xâ‚€ of the curve
var xGen big.Int

// expose the tower -- github.com/consensys/gnark uses it in a gnark circuit

// ğ”½pÂ²
type E2 = fptower.E2

// ğ”½pâ¶
type E6 = fptower.E6

// ğ”½pÂ¹Â²
type E12 = fptower.E12

func init() {
	aCurveCoeff.SetUint64(0)
	bCurveCoeff.SetUint64(3)
	// D-twist
	twist.A0.SetUint64(9)
	twist.A1.SetUint64(1)
	bTwistCurveCoeff.Inverse(&twist).MulByElement(&bTwistCurveCoeff, &bCurveCoeff)

	g1Gen.X.SetOne()
	g1Gen.Y.SetUint64(2)
	g1Gen.Z.SetOne()

	g2Gen.X.SetString("10857046999023057135944570762232829481370756359578518086990519993285655852781",
		"11559732032986387107991004021392285783925812861821192530917403151452391805634")
	g2Gen.Y.SetString("8495653923123431417604973247489272438418190587263600148770280649306958101930",
		"4082367875863433681332203403145435568316851327593401208105741076214120093531")
	g2Gen.Z.SetString("1",
		"0")

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	// (X,Y,Z) = (1,1,0)
	g1Infinity.X.SetOne()
	g1Infinity.Y.SetOne()
	g2Infinity.X.SetOne()
	g2Infinity.Y.SetOne()

	thirdRootOneG1.SetString("2203960485148121921418603742825762020974279258880205651966")
	thirdRootOneG2.Square(&thirdRootOneG1)
	lambdaGLV.SetString("4407920970296243842393367215006156084916469457145843978461", 10) // (36xâ‚€Â³+18xâ‚€Â²+6xâ‚€+1)
	_r := fr.Modulus()
	ecc.PrecomputeLattice(_r, &lambdaGLV, &glvBasis)

	endo.u.A0.SetString("21575463638280843010398324269430826099269044274347216827212613867836435027261")
	endo.u.A1.SetString("10307601595873709700152284273816112264069230130616436755625194854815875713954")
	endo.v.A0.SetString("2821565182194536844548159561693502659359617185244120367078079554186484126554")
	endo.v.A1.SetString("3505843767911556378687030309984248845540243509899259641013678093033130930403")

	// 2-NAF decomposition of 6xâ‚€+2 little endian
	optimaAteLoop, _ := new(big.Int).SetString("29793968203157093288", 10)
	ecc.NafDecomposition(optimaAteLoop, loopCounter[:])

	xGen.SetString("4965661367192848881", 10)

}

// Generators return the generators of the r-torsion group, resp. in ker(pi-id), ker(Tr)
func Generators() (g1Jac G1Jac, g2Jac G2Jac, g1Aff G1Affine, g2Aff G2Affine) {
	g1Aff = g1GenAff
	g2Aff = g2GenAff
	g1Jac = g1Gen
	g2Jac = g2Gen
	return
}

// CurveCoefficients returns the a, b coefficients of the curve equation.
func CurveCoefficients() (a, b fp.Element) {
	return aCurveCoeff, bCurveCoeff
}
